---
title: "GAM evaluation - SF South Bay"
output: 
  html_document:
    css: kable.css
self_contained: yes
runtime: shiny
---
<a href="https://github.com/fawda123/SFBaytrends/" class="github-corner" aria-label="View source on Github"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#FD6C6C; color:#fff; position: absolute; top: 0; border: 0; left: 0; transform: scale(-1, 1);" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>

```{r, message = F, warning = F, results = 'hide', echo = F}
# globals
library(knitr)
opts_chunk$set(warning = FALSE, message = FALSE, dev.args = list(bg = 'transparent'), eval = T, echo = F)

tags$head(includeScript("google-analytics.js"))

library(tidyverse)
library(lubridate)
library(mgcv)
library(shiny)
library(plotly)
library(ggmap)
library(gridExtra)
library(shinyWidgets)

source('R/funcs.R')

data(datprc)
data(modssta)
data(locs)
data(map)
data(modkcmp)

# ext <- make_bbox(locs$lon, locs$lat, f = 0.2)
# map <- get_stamenmap(ext,  zoom = 11, maptype = "toner-lite", where = getwd())
pbase <- ggmap(map) +
  theme_bw() +
  theme(
    axis.title.x = element_blank(),
    axis.title.y = element_blank()
  )
```

## Exploratory plots

```{r}
# create plots for whole time series, by year, by month
# all variables, stations
rawplo <- datprc %>% 
  filter(param %in% 'chl') %>% 
  group_by(station) %>% 
  nest %>% 
  mutate(
    tot = map(data, function(x){
      
      p <- ggplot(x, aes(x = dec_time, y = value)) + 
        geom_line() +
        theme_bw(base_family = 'serif') +
        theme(strip.background = element_blank())
      
      return(p)
      
    }),
    yrs = map(data, function(x){
      
      p <- ggplot(x, aes(x = factor(yr), y = value)) + 
        geom_boxplot(base_family = 'serif') +
        theme_bw(base_family = 'serif') +
        scale_x_discrete("Year") +
        theme(strip.background = element_blank())
      
      return(p)
      
    }), 
    mos = map(data, function(x){
      
      p <- ggplot(x, aes(x = mo, y = value)) + 
        geom_boxplot() +
        theme_bw() +
        theme(strip.background = element_blank())
      
      return(p)
      
    })
  )
```

The following plots show the raw data for all monitoring stations and parameters in South Bay, 1990 - 2017.  Select the parameter, plot type (total time series, by year, or by month), and variable transformation.  The year and month plots are aggregated boxplots of all observations at a station for each selected time period.  The variable transformation can be used to show the observations in arithmetic or logarithmic space.

```{r, echo = F}
# selection widgets
column(4, selectInput("station", "Choose station:", sort(unique(datprc$station))))
column(4, selectInput("typ", "Choose plot type:", c('tot', 'yrs', 'mos')))
column(4, selectInput("log", "Log-space:", c(T, F)))
```

```{r}
# get the plot
toplo <- reactive({

  sel <- rawplo %>% 
    filter(station %in% input$station) %>% 
    select(matches(input$typ)) %>% 
    .[[1]] %>% 
    .[[1]]
  
  if(input$log){
  
    sel <- sel + scale_y_log10('chl')
    
  } else {
    
    sel <- sel + scale_y_continuous('chl')
    
  }
  
  return(sel)
  
})

# make the plot
renderPlot({
  
  # inputs
  station <- input$station
  toplo <- toplo() + 
    theme(axis.title.x = element_blank())
  
  locpt <- locs %>% 
    filter(Station %in% station)
  
  p1 <- pbase + 
    geom_point(data = locpt, aes(x = lon, y = lat), colour = 'tomato1', size = 8) +
    geom_text(data = locs, aes(x = lon, y = lat, label = Station))

  grid.arrange(p1, toplo, widths = c(0.3, 0.7), ncol = 2)
  
}, height = 300, width = 900)

```

## GAMs of log-chlorophyll with annual, seasonal trends

```{r}
# get GAMs for each station, gam0, gam1, and gam2 from baytrends

# smooths to evaluate
frms <- c(
  "log10(chl) ~ dec_time + s(doy, bs = 'cc')",  
  "log10(chl) ~ dec_time + s(dec_time) + s(doy, bs = 'cc')",
  "log10(chl) ~ dec_time + s(dec_time) + s(doy, bs = 'cc') + ti(dec_time, doy, bs = c('tp', 'cc'))"
  ) %>% 
  as.list

# enframe frms for combine with tomod
frms <- frms %>% 
  enframe('modi', 'frm')

# data to model, same as datprc, params in wide format, nested by station
# crossed with frms
tomod <- datprc %>% 
  spread(param, value) %>% 
  group_by(station) %>% 
  nest %>% 
  crossing(frms)

# # create models for every station, gam model eval
# modssta <- tomod %>%
#   mutate(
#     modv = pmap(list(data, frm), function(data, frm){
# 
#       # get upper bounds of knots
#       gamk1 <- data$yr %>%
#         unique %>%
#         length %>% 
#         `*`(2 / 3) %>% 
#         round(0) %>% 
#         pmax(10, .)
# 
#       # insert upper gamk1 if applicable
#       if(grepl('s\\(dec_time', frm)){
#         p1 <- gsub('(^.*)s\\(dec\\_time\\).*$', '\\1', frm)
#         p3 <-  gsub('^.*s\\(dec\\_time\\)(.*)$', '\\1', frm)
#         p2 <- paste0('s(dec_time, k = ', gamk1, ')')
#         frm <- paste0(p1, p2, p3)
#       }
# 
#       gam(as.formula(frm),
#         knots = list(doy = c(1, 366)),
#         data = data,
#         na.action = na.exclude,
#         select = T
#       )
# 
#   })
#   )
# modssta <- modssta %>%
#   mutate(modi = factor(modi, levels = c(1, 2, 3), labels = c('gam0', 'gam1', 'gam2')))
# save(modssta, file = 'data/modssta.RData', compress = 'xz')
```

Generalized additive models (GAMs) were developed to describe trends in chlorophyll-a at each of the monitoring stations in South Bay.  The station and selected model can be chosen from the drop down menus.  Three types of GAMs were developed for the time series at each station to model chlorophyll as a function of time, where time is measured as an annual and seasonal effect.  The three models descibe the time components differently and represent increasing levels of complexity to describe the chlorophyll trend:

* `gam0`: chl ~ year + s(doy)

* `gam1`: chl ~ year + s(doy) + s(year)

* `gam2`: chl ~ year + s(doy) + s(year) + ti(doy, year)

For all models, `year` is measured as a continuous numeric variable for the annual effect (e.g., January 1st, 2000 is 2000.0, July 1st, 2000 is 2000.5, etc.) and `doy` is the day of year as a numeric value from 1 to 366.  All models include `year` as a linear effect.  The functions `s()` model either `year` or `doy` as a smoothed, non-linear variable and `ti()` models the interaction between the two.

__Select the station with the drop down menu for the summary of all three GAM chlorophyll models.__  

The first table shows the individual effects of the modelled components of each model as the estimated degrees of freedom (`edf`), the reference degrees of freedom (`Ref.df`), the test statistic (`F`), and significance of the component (`p-value`).  The significance of the component is in part based on the difference between `edf` and `Ref.df`.  The second table shows the overall summary of each model as Akaike Information Criterion (`AIC`), the generalized cross-validation score (`GCV`), and the `R2` values.  Lower values for `AIC` and `GCV` and higher values for `R2` indicate improved model fit.  

The two plots show the predicted trends from each of the three models.  The first plot shows estimed chlorophyll by day of year with separate lines for each year.  The second plot show predictions for the three models across the entire time series. 

```{r}
mods <- reactive({
  modssta %>% filter(station %in% input$station)
})

# smoother stats of GAMs
renderTable({
  map(mods()$modv, ~ summary(.x)$s.table %>% data.frame %>% rownames_to_column('smoother')) %>% 
    enframe %>% 
    rename(model = name) %>% 
    mutate(model = factor(model, levels = c(1, 2, 3), labels = c('gam0', 'gam1', 'gam2'))) %>% 
    unnest
})

# summary stats of GAMs, model fit/perf
renderTable({
  map(mods()$modv, ~ data.frame(
      AIC = AIC(.x), 
      GCV = .x$gcv.ubre,
      R2 = summary(.x)$r.sq)) %>% 
    enframe %>% 
    rename(model = name) %>% 
    mutate(model = factor(model, levels = c(1, 2, 3), labels = c('gam0', 'gam1', 'gam2'))) %>% 
    unnest
})
```

```{r}
# prediction data
prdplo <- reactive({
    
  prdplo <- mods() %>%
    mutate(prddat = pmap(list(data, modv), function(data, modv){
  
  
      prddat <- data.frame(
          dec_time = seq(min(data$dec_time), max(data$dec_time), length = 1000)
        ) %>%
        mutate(
          date = date_decimal(dec_time),
          date = as.Date(date),
          mo = month(date, label = TRUE),
          doy = yday(date),
          yr = year(date)
        )
  
      prd <- predict(modv, newdata = prddat)
      
      prddat <- prddat %>% mutate(chl = prd)
  
      return(prddat)
      
    })) %>% 
    select(modi, prddat) %>% 
    unnest
  
  return(prdplo)
  
})

rawchl <- reactive({
  rawchl <- mods()$data[[1]]
})

# facet by mod, doy x axis, lines by year
renderPlot({
  p <- ggplot(prdplo(), aes(x = doy, group = factor(yr), colour = yr)) + 
    geom_line(aes(y = chl)) + 
    theme_bw(base_family = 'serif', base_size = 16) + 
    theme(
      legend.position = 'top', 
      legend.title = element_blank()
      ) + 
    scale_y_continuous('log10(chl)') +
    facet_wrap(~ modi, ncol = 3) +
    guides(colour = guide_colourbar(barheight = 1, barwidth = 20)) + 
    ggtitle(paste0('Station', input$station))
  p
}, height = 400, width = 900)

# plot predictions, all mods, by time
renderPlot({
  # plot
  p <- ggplot(prdplo(), aes(x = date)) + 
    geom_point(data = rawchl(), aes(y = log10(chl)), size = 0.5) +
    geom_line(aes(y = chl, colour = factor(modi))) + 
    stat_smooth(aes(y = chl, group = modi), se = F, method = "loess", color = 'black', alpha = 0.7) +
    facet_wrap(~modi, ncol = 1) +
    theme_bw(base_family = 'serif', base_size = 16) + 
    theme(
      legend.position = 'top', 
      legend.title = element_blank(),
      strip.text = element_blank(), 
      strip.background = element_blank()
      ) + 
    ggtitle(paste0('Station', input$station))
  p
}, height = 600)
```

### Individual model for selected station and trend assessment

__Selected station:  `r renderText({input$station})`__

The following provides additional information for one of the three models for the selected station.  __Use the drop down menu to select a specific model.__  The tables repeat the information above but only for the selected model.  The four plots show 1) plot diagnostics of the model fit, 2) the predicted trends across the time series (and options for trend assessment), 3) the predicted trends with separate lines for each month across the time series, and 4) a three-dimensional fit of the estimate trends across year and day of year with the z-axis showing estimated chlorophyll. 

```{r, echo = F}
selectInput('mod', "Select a model:", unique(modssta$modi))
```
```{r}
# smoother stats of GAMs
renderTable({
  
  md <- mods() %>% 
    filter(modi %in% input$mod) %>% 
    .$modv %>% 
    .[[1]]
  tab <- summary(md)$s.table %>% data.frame %>% rownames_to_column('smoother')
  return(tab)

})

# summary stats of GAMs, model fit/perf
renderTable({
  
  md <- mods() %>% 
    filter(modi %in% input$mod) %>% 
    .$modv %>% 
    .[[1]] 
  tab <- data.frame(
    AIC = AIC(md), 
    GCV = md$gcv.ubre,
    R2 = summary(md)$r.sq)
  return(tab)
  
})
renderPlot({
  md <- mods() %>% 
    filter(modi %in% input$mod) %>% 
    .$modv %>% 
    .[[1]] 
  gam.check(md)
}, height = 550)
```

```{r}
column(4,
       renderUI({
         
         yrs <- mods()$data[[1]] %>% pull(yr) %>% unique
         
         pickerInput('yrbs', 'Select base years:', choices = yrs, selected = yrs[c(1,2)], multiple = T)
         
         })
)
column(4,
       renderUI({
         
         # unique years x 2/3
         yrs <- mods()$data[[1]] %>% pull(yr) %>% unique
         
         pickerInput('yrts', 'Select test years:', choices = yrs, selected = rev(yrs)[c(1,2)], multiple = T)
         
         })
)
```

```{r}
# trend ests, estimated data and results
trnds <- reactive({
  
  req(input$yrbs)
  
  # inputs
  yrbs <- as.numeric(input$yrbs)
  yrts <- as.numeric(input$yrts)
  mod <- input$mod
  mods <- mods()

  # input model
  modv <- mods %>% 
    filter(modi %in% mod) %>% 
    pull(modv) %>% 
    .[[1]]
  
  # trnds
  trnds <- gamdiff(modv, yrbs, yrts) %>% 
    .[c('pdat', 'per.mn', 'per.mn.obs', 'pct.chg', 'diff.pval')]
  
  return(trnds)
  
})

# windows evaluated for trends, to plot
trndswn <- reactive({
  
  req(trnds())

  # input
  trnds <- trnds()

  toplo <- trnds$pdat %>% 
    select(-doy) %>% 
    mutate(
      date = date_decimal(dec_time, tz = 'Pacific/Pitcairn'), 
      date = as.Date(date),
      bl = as.numeric(bl), 
      bl = as.factor(bl)
    ) %>% 
    select(-dec_time) %>% 
    group_by(year) %>% 
    filter(date %in% range(date)) %>% 
    ungroup %>% 
    mutate(xval = ifelse(duplicated(year), 'xmax', 'xmin')) %>% 
    spread(xval, date)
  
  return(toplo)
  
})

# trend results in text format
trndstx <- reactive({
  
  req(trnds())
  
  # input
  trnds <- trnds()
  
  # format
  pval <- p_ast(trnds$diff.pval)
  out <- trnds[!names(trnds) %in% c('diff.pval', 'pdat')] %>% 
    enframe %>% 
    unnest %>% 
    mutate(
      value = round(value, 2)
    )
  out <- paste0('Base: ', out$value[3], ' (', out$value[1], '), Test: ', out$value[4], ' (', out$value[2], '), Change: ', out$value[5], '%, ', pval)
  
  return(out)

})
```

```{r}
# plot predictions, selected mod
renderPlot({

  # inputs
  mod <- input$mod
  prdplo <- prdplo()
  rawchl <- rawchl()
  trndswn <- trndswn()
  trndstx <- trndstx()

  # get selected model
  toplo <- prdplo %>% filter(modi %in% mod)

  # plot
  p <- ggplot() + 
    geom_rect(data = trndswn, aes(xmin = xmin, xmax = xmax, ymin = -Inf, ymax = Inf, group = year, fill = bl), alpha = 0.7) +
    geom_point(data = rawchl, aes(x = date, y = log10(chl)), size = 0.5) +
    geom_line(data = toplo, aes(x = date, y = chl)) + 
    theme_bw(base_family = 'serif', base_size = 16) + 
    scale_fill_manual(values = c('lightblue', 'lightgreen')) +
    theme(
      legend.position = 'none', 
      legend.title = element_blank(),
      strip.text = element_blank(), 
      strip.background = element_blank()
      ) +
    ggtitle(trndstx)
  p
}, height = 320)
```

```{r}
# prediction data
prdplost <- reactive({
  
  outprd <- mods() %>% 
    filter(modi %in% input$mod) %>%
    mutate(prddat = pmap(list(data, modv), function(data, modv){

      data <- data$date %>% 
        range(na.rm  = T)
      data <- seq.Date(floor_date(data[1], 'month'), ceiling_date(data[2], 'month'), by = 'days') %>% 
        tibble(date = .) %>% 
        mutate(
          doy = yday(date), 
          dec_time = decimal_date(date),
          yr = year(date)
          )
      prd <- predict(modv, newdata = data)
      out <- data.frame(data, chl = prd)
      
      return(out)
      
    })
  
  ) %>% 
  select(modi, prddat) %>% 
  unnest %>% 
  select(-modi)
  
  return(outprd)
  
})
```

```{r}
renderPlot({
  
  toplo <- prdplost() %>% 
    mutate(day = day(date)) %>% 
    filter(day %in% c(1)) %>% 
    mutate(month = month(date, label = T))
  
  # plot
  p <- ggplot(toplo, aes(x = date)) + 
    geom_point(data = rawchl(), aes(y = log10(chl)), size = 0.5) +
    geom_line(aes(y = chl, group = month, colour = month), size = 1, alpha = 0.7) + 
    theme_bw(base_family = 'serif', base_size = 16) + 
    theme(
      legend.position = 'top'
      ) 
  p
})
```

```{r, out.width = "100%"}
renderPlotly({
  
  logchl <- prdplost() %>% 
    select(-date, -dec_time) %>% 
    spread(yr, chl) %>% 
    select(-doy) %>% 
    as.matrix
  
  scene <- list(
    aspectmode = 'manual', 
    aspectratio = list(x = 1, y = 1, z = 0.5), 
    xaxis = list(title = 'Years from time zero'), 
    yaxis = list(title = 'Day of year'), 
    zaxis = list(title = 'log-Chl'),
    roughness = .01,
    ambient = 0.9
  )
  
  p <- plot_ly(z = ~logchl, height = 600) %>% 
    add_surface(colors = rev(RColorBrewer::brewer.pal(11, 'Spectral'))) %>% 
    layout(scene = scene)
  p
  
})
```

</br>
</br>
</br>
</br>
</br>
</br>
</br>
</br>
</br>

### Evaluate k smoothers 

This section applies only to gam1 and gam2 models that include the `s(year)` smoother. Choose the station at the top of this page then select the model (gam1 or gam2) and the two k values to compare.  The default values are ten and 2/3 times the number of years in the record for the selected station.

__Selected station: `r renderText({input$station})`__

```{r}
column(4, selectInput('gamtyp', 'Select gam type:', 
                      choices = list(
                        gam1 = "log10(chl) ~ dec_time + s(dec_time) + s(doy, bs = 'cc')", 
                        gam2 = "log10(chl) ~ dec_time + s(dec_time) + s(doy, bs = 'cc') + ti(dec_time, doy, bs = c('tp', 'cc'))" 
                          )
                      )
       )
column(4, numericInput('gamk1_1', 'First comparison for k:', value = 10))
column(4,
       renderUI({
         
         # unique years x 2/3
         yrs <- mods()$data[[1]] %>% pull(yr) %>% unique %>% length %>% `*` (2/3) %>% round(0)
         
         numericInput('gamk1_2', 'Second comparison for k:', value = yrs)
         
         })
)
```

```{r}
# k1 comparisons, models only
modsk1 <- reactive({
  
  req(input$gamk1_2)
  
  # inputs
  gamtyp <- input$gamtyp
  gamk1_1 <- input$gamk1_1
  gamk1_2 <- input$gamk1_2
  mods <- mods()
  
  # get model formula for correct mod type, by knot selection
  p1 <- gsub('(^.*)s\\(dec\\_time\\).*$', '\\1', gamtyp)
  p3 <-  gsub('^.*s\\(dec\\_time\\)(.*)$', '\\1', gamtyp)
  frms <- sapply(c(gamk1_1, gamk1_2), function(x){
    p2 <- paste0('s(dec_time, k = ', x, ')')
    paste0(p1, p2, p3)
  })
  
  # two compared models wiht different k
  modsk1 <- mods$data[[1]] %>% 
    crossing(frms = frms, data = .) %>% 
    group_by(frms) %>% 
    nest %>% 
    mutate(
      modv = pmap(list(frms, data), function(frms, data){
        
        gam(as.formula(frms),
          knots = list(doy = c(1, 366)),
          data = data,
          na.action = na.exclude,
          select = T
        )
        
      })
      
    )

  return(modsk1)

})
```

```{r}
# prediction data for gamk1 comparisons
prdplok1 <- reactive({
  
  req(modsk1())

  prdplok1 <- modsk1() %>%
    mutate(prddat = pmap(list(data, modv), function(data, modv){
  
      prddat <- data.frame(
          dec_time = seq(min(data$dec_time), max(data$dec_time), length = 1000)
        ) %>%
        mutate(
          date = date_decimal(dec_time),
          date = as.Date(date),
          mo = month(date, label = TRUE),
          doy = yday(date),
          yr = year(date)
        )
  
      prd <- predict(modv, newdata = prddat)
      
      prddat <- prddat %>% mutate(chl = prd)
  
      return(prddat)
      
    })) %>% 
    select(-data, -modv) %>% 
    unnest

  return(prdplok1)
  
})

```

```{r}
# summary stats of two k comparisons
renderTable({

  # inputs
  gamk1_1 <- input$gamk1_1
  gamk1_2 <- input$gamk1_2
  modsk1 <- modsk1()
  
  modsk1 <- modsk1 %>% 
    mutate(
      frms = gsub('.*\\s([0-9]+)\\).*', '\\1', frms),
      ests = map(modv, ~ data.frame(
        AIC = AIC(.x), 
        GCV = .x$gcv.ubre,
        R2 = summary(.x)$r.sq)
        )
      ) %>% 
    dplyr::select(-modv, -data) %>% 
    unnest
  
  modsk1
  
})
```

```{r}
# prediction plot, two knot comparisons
renderPlot({

  req(prdplok1())
  rawchl <- modsk1()$data[[1]]

  p <- ggplot() + 
    geom_point(data = rawchl, aes(x = dec_time, y = log10(chl)), size = 0.5) +
    geom_line(data = prdplok1(), aes(x = dec_time, group = factor(frms), colour = frms, y = chl)) + 
    theme_bw(base_family = 'serif', base_size = 16) + 
    theme(
      legend.position = 'top', 
      legend.title = element_blank(), 
      axis.title.x = element_blank()
      ) + 
    scale_y_continuous('log10(chl)') +
    guides(colour = guide_legend(ncol = 1)) +
    ggtitle(paste0('Station', input$station))
  p
}, height = 400, width = 900)

# summary of 1-100 knots
renderPlot({
  
  # inputs
  station <- input$station
  gamtyp <- input$gamtyp
  gamk1_1 <- input$gamk1_1
  gamk1_2 <- input$gamk1_2
  
  # subset all by correct gamtyp
  if(grepl('ti\\(', gamtyp)) 
    gamtyp <- 'gam2'
  else 
    gamtyp <- 'gam1'
  
  # all pts
  toplo <- modkcmp %>% 
    filter(station %in% input$station) %>% 
    filter(modi %in% gamtyp)
  
  # only those for selected
  toplo2 <- toplo %>% 
    filter(ks %in% c(gamk1_1, gamk1_2))
  
  p <- ggplot(toplo, aes(x = ks, y = AIC)) + 
    geom_point(size = 2.5, pch = 21, fill = 'grey', color = 'black') + 
    geom_point(data = toplo2, pch = 21, fill = 'tomato1', color = 'black', size = 4) +
    theme_bw(base_family = 'serif', base_size = 16) + 
    theme(
      strip.background = element_blank(), 
      legend.title = element_blank(), 
      legend.position = 'top'
    ) + 
    scale_x_continuous('Selected k')
  
  return(p)
  
}, height = 320, width = 900)
```

